<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">





















<title>Lambda Soup - Functional HTML Scraping for OCaml</title>
</head>
<body>

<div class="head">
  <div class="top-links">
    <a class="github" href="https://github.com/aantron/lambda-soup">GitHub</a>
    <a href="https://github.com/aantron/lambda-soup#installing">Installing</a>
    <a href="https://github.com/aantron/lambda-soup/blob/master/docs/CONTRIBUTING.md">
      Contributing
    </a>
  </div>

  <h1>Lambda Soup</h1>
</div>

<pre><span class="keyword">module</span> Soup: <code class="code">sig</code> .. <code class="code">end</code></pre><div class="info module top">
Easy functional HTML scraping and manipulation for OCaml.<br>
</div><div class="info">
  <p>
    Lambda Soup is an HTML data extraction and analysis library, in the sense of
    Python's
    <a href="http://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a>.
    It supports various element traversals, CSS selectors, DOM manipulations,
    and conversion of loaded HTML back to string. This very documentation page
    was generated by <code>ocamldoc</code> and
    <a href="https://github.com/aantron/lambda-soup/blob/master/docs/postprocess.ml">
      postprocessed</a> by Lambda Soup!
  </p>

  <p>Here are some usage examples:</p>

  <pre><code class="code">open Soup

let soup = read_channel stdin |&gt; parse in

(* Print the page title. *)
soup $ "title" |&gt; R.leaf_text |&gt; print_endline;

(* Print the targets of all links. *)
soup $$ "a[href]"
|&gt; iter (fun a -&gt; R.attribute "href" a |&gt; print_endline);

(* Find the first unordered list. *)
let ul = soup $ "ul" in

(* Print the contents of all its items. *)
ul $$ "li" |&gt; to_list
|&gt; List.iter (fun li -&gt;
  trimmed_texts li |&gt; String.concat "" |&gt; print_endline)

(* Find all subsequent sibling elements of the same list. *)
let _ = ul $$ "~ *" in

(* Find all previous sibling elements instead. *)
let _ = ul |&gt; previous_siblings |&gt; elements in

(* ... *)</code></pre>

  <p>
    Lambda Soup is based around two types: <em>nodes</em>, whose meaning should
    be obvious, and <em>traversals</em>, which are lazy sequences of nodes. The
    top-level node is the <em>soup</em> node (a.k.a. document node), which you
    typically get by calling <code>parse</code> on a string containing HTML.
  </p>

  <p>
    Once you have a node, you can call functions such as
    <code>descendants</code>, <code>ancestors</code>,
    <code>previous_siblings</code>, and, most commonly of all,
    <code>select</code>, to get to other nodes. Once there, you can start new
    traversals, compute values, cause side effects, and do whatever your
    application requires. Traversals come with a typical suite of functional
    transformations, such as <code>map</code>, <code>fold</code>, and
    <code>filter</code>. Traversals can also be terminated early, so you don't
    have to go through the entire document once you find the node you are
    looking for.
  </p>

  <p>
    The main goals of Lambda Soup are to be correct and to be easy to use for
    simple scraping and processing tasks. I'd love to hear ways in which the
    interface can be improved. Feedback is very welcome!
  </p>

  <p>
    Lambda Soup is developed on
    <a href="https://github.com/aantron/lambda-soup">GitHub</a> and distributed
    under the BSD license.
  </p>

  <p>
    This documentation page is for version 0.6 of the library.
  </p>
<div class="toc"><p>Module contents</p><div class="links"><a class="hide-narrow" href="#">[Top]</a><br><br><a href="#2_Types">Types</a><br><a href="#2_Highlevelinterface">High-level interface</a><br><a href="#2_Options">Options</a><br><a href="#2_Earlytermination">Early termination</a><br><a href="#2_Elementaccess">Element access</a><br><a href="#2_Contentaccess">Content access</a><br><a href="#2_Elementarytraversals">Elementary traversals</a><br><a href="#2_Combinators">Combinators</a><br><a href="#2_Projection">Projection</a><br><a href="#2_Convenience">Convenience</a><br><a href="#2_Printing">Printing</a><br><a href="#2_Parsingsignals">Parsing signals</a><br><a href="#2_Equality">Equality</a><br><a href="#2_Mutation">Mutation</a><br><a href="#2_Optionconveniencemodule">Option convenience module</a><br><a href="#2_IO">I/O</a><br></div><br><br><a class="github hide-narrow" href="https://github.com/aantron/lambda-soup">GitHub</a></div></div>


<h2 id="2_Types">Types</h2>

<pre><span id="TYPEelement"><span class="keyword">type</span> <code class="type"></code>element</span> </pre>


<pre><span id="TYPEgeneral"><span class="keyword">type</span> <code class="type"></code>general</span> </pre>


<pre><span id="TYPEsoup"><span class="keyword">type</span> <code class="type"></code>soup</span> </pre>
<div class="info ">
"Phantom" types for use with <code class="code">'a node</code>. See explanation below.<br>
</div>


<pre><span id="TYPEnode"><span class="keyword">type</span> <code class="type">'a</code> node</span> </pre>
<div class="info ">
HTML document nodes. These come in three varieties: <code class="code">element node</code>
    represents a node that is known to be an element, <code class="code">soup node</code> represents an
    entire document, and <code class="code">general node</code> represents a node that might be
    anything, including elements, documents, text content, and other kinds of
    HTML nodes that Lambda Soup doesn't yet support.
<p>

    Throughout Lambda Soup, if a function can operate on any kind of node, the
    argument is typed as <code class="code">_ node</code>. If an element node or the entire document is
    required, the argument type is <code class="code">element node</code> or <code class="code">soup node</code>,
    respectively.<br>
</p></div>


<pre><span id="TYPEnodes"><span class="keyword">type</span> <code class="type">'a</code> nodes</span> </pre>
<div class="info ">
Sequence of nodes. This is always instantiated as either <code class="code">element nodes</code> or
    or <code class="code">general nodes</code>. The sequence is <em>lazy</em> in the sense that only as many
    elements as needed are evaluated. This can be used with <a href="#VALwith_stop"><code class="code">with_stop</code></a> to
    traverse only part of a document until some condition is reached.<br>
</div>


<h2 id="2_Highlevelinterface">High-level interface</h2>

<pre><span id="VALparse"><span class="keyword">val</span> parse</span> : <code class="type">string -&gt; <a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Parses the given HTML text and evaluates to a document node containing the
    top-level HTML nodes found. Entity references are resolved, and the
    character encoding is detected automatically.
<p>

    If you need to parse XML, or control over parsing, or want to feed Lambda
    Soup something other than bytes, see
    <a href=" #2_Parsingsignals"> Parsing signals</a>.<br>
</p></div>

<pre><span id="VALselect"><span class="keyword">val</span> select</span> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">select selector node</code> is all the descendants of <code class="code">node</code> matching CSS
    selector <code class="code">selector</code>. All
    <a href=" http://www.w3.org/TR/selectors/#selectors"> CSS3 selectors</a> are
    supported, with the following exceptions, each of which only makes sense
    when doing layout or displaying an interactive interface:
<p>

</p><pre class="codepre"><code class="code">:link, :visited, :hover, :active, :focus, :target, :lang, :enabled,
:disabled, :checked, :indeterminate, ::first-line, ::first-letter,
::selection, ::before, ::after
</code></pre>
<p>

    There is also no support for XML namespace selectors. Instead, Lambda Soup
    supports the apparently-dropped
    <a href=" http://www.w3.org/TR/2001/CR-css3-selectors-20011113/#content-selectors">
    <code class="code">:contains("foo")</code></a> pseudo-class. You can see some examples of supported
    selectors in the
    <a href=" https://github.com/aantron/lambda-soup/blob/master/test/test.ml#L47">
    tests</a>.
</p><p>

    Lambda Soup selector syntax supports an extension of CSS. In regular CSS,
    the selector cannot start with a combinator such as <code class="code">&gt;</code>. Instead, you have
    to write things such as <code class="code">* &gt; p</code>, which has a different meaning than what
    <code class="code">&gt; p</code> might mean. Lambda Soup allows selectors such as <code class="code">&gt; p</code>, <code class="code">+ p</code>, and
    <code class="code">~ p</code> to select immediate children of <code class="code">node</code>, adjacent next siblings, and
    all next siblings, respectively. In addition, you can use the empty selector
    to select <code class="code">node</code> itself. Note, in this latter case, that if <code class="code">node</code> is not an
    element (for example, it is often the soup node), the select will result in
    nothing, because select always results in sequences of <em>element</em> nodes
    only.<br>
</p></div>

<pre><span id="VALselect_one"><span class="keyword">val</span> select_one</span> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <code class="code">select</code>, but evaluates to at most one element. Note that there is also
    <code class="code">R.select_one</code> if you don't want an option result, which is explained at
    <a href="#VALrequire"><code class="code">require</code></a>.<br>
</div>

<pre><span id="VAL($)"><span class="keyword">val</span> ($)</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
<code class="code">node $ selector</code> is the same as
    <code class="code">node |&gt; select_one selector |&gt; require</code>.<br>
</div>

<pre><span id="VAL($?)"><span class="keyword">val</span> ($?)</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">node $? selector</code> is the same as <code class="code">node |&gt; select_one selector</code>.<br>
</div>

<pre><span id="VAL($$)"><span class="keyword">val</span> ($$)</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">node $$ selector</code> is the same as <code class="code">node |&gt; select selector</code>.<br>
</div>

<h2 id="2_Options">Options</h2>

<pre><span id="VALrequire"><span class="keyword">val</span> require</span> : <code class="type">'a option -&gt; 'a</code></pre><div class="info ">
<code class="code">require (Some v)</code> evaluates to <code class="code">v</code>, and <code class="code">require None</code> raises <code class="code">Failure</code>.
    Many functions in Lambda Soup return options, such as <code class="code">select_one</code> above.
    When you know, better than the type system, that a value will definitely be
    present, <code class="code">require</code> can be used to conveniently eliminate the option and get
    the value out.
<p>

    Note that there is also a module <code class="code">R</code> provided, which contains, for each
    function that evaluates to an option, a version of the function that is
    post-composed with <code class="code">require</code>, and thus returns an unwrapped value (or raises
    <code class="code">Failure</code>). So, instead of writing <code class="code">soup |&gt; children |&gt; first |&gt; require</code>,
    you can write <code class="code">soup |&gt; children |&gt; R.first</code>.
</p><p>

    As an alternative to using <code class="code">require</code> and <code class="code">R</code>, consider using an option
    monad.<br>
</p></div>

<h2 id="2_Earlytermination">Early termination</h2>

<pre><code><span id="TYPEstop"><span class="keyword">type</span> <code class="type">'a</code> stop</span> = {</code></pre><table class="typetable">
<tbody><tr>
<td align="left" valign="top">
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top">
<code><span id="TYPEELTstop.throw">throw</span>&nbsp;: <code class="type">'b. 'a -&gt; 'b</code>;</code></td>

</tr></tbody></table>
}

<div class="info ">
A "polymorphic exception handler"/"continuation" used for early termination.
    See <code class="code">with_stop</code> below.<br>
</div>


<pre><span id="VALwith_stop"><span class="keyword">val</span> with_stop</span> : <code class="type">('a <a href="#TYPEstop">stop</a> -&gt; 'a) -&gt; 'a</code></pre><div class="info ">
<code class="code">with_stop (fun stop -&gt; e)</code> evaluates to <code class="code">v</code> if <code class="code">e</code> evaluates to <code class="code">v</code>. If
    <code class="code">e</code> calls <code class="code">stop.throw w</code>, <code class="code">with_stop</code> evaluates to <code class="code">w</code>. In plainer words,
    <code class="code">with_stop</code> creates an exception handler, to which the body <code class="code">e</code> can return a
    value by calling <code class="code">stop.throw</code>. This is meant for use with lazy node
    sequences. For example, here is an expression that finds the first node with
    a <code class="code">draggable</code> attribute, stopping traversal immediately when that occurs:
<p>

</p><pre class="codepre"><code class="code">with_stop (fun stop -&gt;
  some_root_node
  |&gt; descendants
  |&gt; elements
  |&gt; fold (fun _ e -&gt;
    if has_attribute "draggable" e then stop.throw (Some e)
    else None) None)
</code></pre>
<p>

    Of course, the <code class="code">fold</code> can be done more easily using <code class="code">filter</code> and <code class="code">first</code>,
    declared below, so this is only a demonstration.<br>
</p></div>

<h2 id="2_Elementaccess">Element access</h2>

<pre><span id="VALname"><span class="keyword">val</span> name</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string</code></pre><div class="info ">
Given an element node, evaluates to its tag name. For example, an element
    <code class="code">&lt;a id="foo"&gt;&lt;/a&gt;</code> has tag name <code class="code">a</code>. All tag names are converted to
    lowercase.<br>
</div>

<pre><span id="VALattribute"><span class="keyword">val</span> attribute</span> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string option</code></pre><div class="info ">
<code class="code">attribute attr element</code> evaluates to <code class="code">Some v</code> if <code class="code">element</code> has attribute
    <code class="code">attr</code> and it is set to value <code class="code">v</code>, and <code class="code">None</code> if <code class="code">element</code> does not have
    <code class="code">attr</code>. In simpler words, <code class="code">attribute</code> gets <code class="code">attr</code> from <code class="code">element</code>.<br>
</div>

<pre><span id="VALclasses"><span class="keyword">val</span> classes</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string list</code></pre><div class="info ">
Evaluates to the class list of the given element.<br>
</div>

<pre><span id="VALid"><span class="keyword">val</span> id</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; string option</code></pre><div class="info ">
Evaluates to the id of the given element, if it is present.<br>
</div>

<pre><span id="VALhas_attribute"><span class="keyword">val</span> has_attribute</span> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
<code class="code">has_attribute attr element</code> evaluates to <code class="code">true</code> if and only if <code class="code">element</code>
    has <code class="code">attr</code>.<br>
</div>

<pre><span id="VALfold_attributes"><span class="keyword">val</span> fold_attributes</span> : <code class="type">('a -&gt; string -&gt; string -&gt; 'a) -&gt; 'a -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a</code></pre><div class="info ">
<code class="code">fold_attributes f init element</code> applies <code class="code">f</code> successively to the names and
    values of the attributes of <code class="code">element</code>. The first <code class="code">string</code> argument to <code class="code">f</code> is
    the attribute name, and the second is the value.<br>
</div>

<pre><span id="VALelement"><span class="keyword">val</span> element</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Given a general node, asserts that it is an element <code class="code">e</code>. If so, evaluates to
    <code class="code">Some e</code>. Otherwise, evaluates to <code class="code">None</code>. In simpler words, performs a
    checked coercion of a general node up to an element.<br>
</div>

<pre><span id="VALelements"><span class="keyword">val</span> elements</span> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Given a sequence of nodes, transforms it into a sequence containing only the
    element nodes, i.e. filters out non-elements.<br>
</div>

<pre><span id="VALis_element"><span class="keyword">val</span> is_element</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Evalautes to <code class="code">true</code> if and only if the given node is an element.<br>
</div>

<h2 id="2_Contentaccess">Content access</h2>

<pre><span id="VALleaf_text"><span class="keyword">val</span> leaf_text</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string option</code></pre><div class="info ">
<code class="code">leaf_text n</code> is defined recursively as follows:
<p>
</p><ul>
<li>If <code class="code">n</code> is a text node with value <code class="code">s</code>, <code class="code">leaf_text n</code> evaluates to <code class="code">Some s</code>.</li>
<li>If <code class="code">n</code> is an element or soup node, then, <code class="code">leaf_text n</code> filters out all
      text children of <code class="code">n</code> containing only whitespace. If there is only one
      child <code class="code">n'</code> remaining, it evaluates to <code class="code">leaf_text n'</code>. If there are no
      children remaining, it evaluates to <code class="code">Some ""</code>. If there are two or more
      children remaining, it evaluates to <code class="code">None</code>.</li>
</ul>

    Less formally, <code class="code">leaf_text n</code> "drills down" to a single leaf node contained
    under <code class="code">n</code>, and extracts its text, if any. While doing this, it ignores
    whitespace. If the choice of leaf is ambiguous, the result is <code class="code">None</code>.
<p>

    Here are some examples of what <code class="code">leaf_text</code> produces (<code class="code">=&gt;</code>) for various
    nodes:
</p><p>

</p><pre class="codepre"><code class="code">some text                                =&gt;   Some "some text"
&lt;p&gt;some text&lt;/p&gt;                         =&gt;   Some "some text"
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;              =&gt;   Some "some text"
&lt;div&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;             =&gt;   Some "some text"
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;p&gt;more&lt;/p&gt;&lt;/div&gt;   =&gt;   None
&lt;div&gt;&lt;/div&gt;                              =&gt;   Some ""
</code></pre><br>
</div>

<pre><span id="VALtexts"><span class="keyword">val</span> texts</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string list</code></pre><div class="info ">
Given a node <code class="code">n</code>, evaluates to the content of all text nodes that are
    descendants of <code class="code">n</code>. If <code class="code">n</code> is itself a text node, returns <code class="code">n</code>'s content.<br>
</div>

<pre><span id="VALtrimmed_texts"><span class="keyword">val</span> trimmed_texts</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string list</code></pre><div class="info ">
Same as <code class="code">texts</code>, but all strings are passed through <code class="code">String.trim</code>, and then
    all empty strings are filtered out.<br>
</div>

<h2 id="2_Elementarytraversals">Elementary traversals</h2>

<pre><span id="VALchildren"><span class="keyword">val</span> children</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
The sequence of all children of a node <code class="code">n</code>, including non-element children.
    To get child elements, use <code class="code">children |&gt; elements</code> or <code class="code">$$ "&gt; *"</code>. If <code class="code">n</code> is
    not itself an element or the document, it cannot have children, so the
    traversal is empty.<br>
</div>

<pre><span id="VALdescendants"><span class="keyword">val</span> descendants</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Sequence of all descendants of a node <code class="code">n</code>. <code class="code">n</code> is not considered its own
    descendant. To get only the elements, use <code class="code">descendants |&gt; elements</code> or
    <code class="code">$$ "*"</code>. As with <code class="code">children</code>, if <code class="code">n</code> is not an element or the document, it
    cannot have descendants, so the traversal is empty.<br>
</div>

<pre><span id="VALancestors"><span class="keyword">val</span> ancestors</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Sequence of ancestors of a node <code class="code">n</code>. <code class="code">n</code> is not considered its own
    ancestor. The document node is not included in the traversal. Ancestors are
    ordered by proximity to <code class="code">n</code>, i.e. the sequence goes up the DOM tree to a
    root element.<br>
</div>

<pre><span id="VALnext_siblings"><span class="keyword">val</span> next_siblings</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Sequence of siblings of a node <code class="code">n</code> that follow <code class="code">n</code> in its parent's child
    list.<br>
</div>

<pre><span id="VALprevious_siblings"><span class="keyword">val</span> previous_siblings</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Sequence of siblings of a node <code class="code">n</code> that precede <code class="code">n</code> in its parent's child
    list. The sequence is ordered according to proximity to <code class="code">n</code>, i.e. the
    nearest node to <code class="code">n</code> is first. This is the opposite order of these nodes in
    the parent's child list.<br>
</div>

<h2 id="2_Combinators">Combinators</h2>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -&gt; 'b <a href="#TYPEnode">node</a> -&gt; 'a) -&gt; 'a -&gt; 'b <a href="#TYPEnodes">nodes</a> -&gt; 'a</code></pre><div class="info ">
<code class="code">fold f init t</code> folds <code class="code">f</code> over the nodes of <code class="code">t</code>, i.e. if <code class="code">t</code> is
    <code class="code">n, n', n'', ...</code>, evaluates <code class="code">f (f (f init n) n') n'' ...</code>.<br>
</div>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; bool) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">filter f t</code> is the sequence consisting of the nodes <code class="code">n</code> of <code class="code">t</code> for which
    <code class="code">f n</code> evaluates to <code class="code">true</code>.<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a>) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'b <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">map f t</code> is the sequence consisting of nodes <code class="code">f n</code> for each node <code class="code">n</code> of
    <code class="code">t</code>.<br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> option) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'b <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">filter_map f t</code> is the sequence consisting of nodes <code class="code">n'</code> for each node <code class="code">n</code>
    of <code class="code">t</code> for which <code class="code">f n</code> evaluates to <code class="code">Some n'</code>. Nodes <code class="code">n</code> for which <code class="code">f n</code>
    evaluates to <code class="code">None</code> are dropped.<br>
</div>

<pre><span id="VALflatten"><span class="keyword">val</span> flatten</span> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnodes">nodes</a>) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'b <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
<code class="code">flatten f t</code> is the sequence consisting of the concatenation of all the
    sequences <code class="code">f n</code> for each <code class="code">n</code> in <code class="code">t</code>.<br>
</div>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a <a href="#TYPEnode">node</a> -&gt; unit) -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; unit</code></pre><div class="info ">
<code class="code">iter f t</code> applies <code class="code">f</code> to each node in <code class="code">t</code>.<br>
</div>

<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> list</code></pre><div class="info ">
Converts the given node sequence to a list.<br>
</div>

<h2 id="2_Projection">Projection</h2>

<pre><span id="VALnth"><span class="keyword">val</span> nth</span> : <code class="type">int -&gt; 'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">nth n t</code> evaluates to the <code class="code">n</code>th element of <code class="code">t</code>, if it is present. Note that
    the index is 1-based. This is for consistency with the CSS <code class="code">:nth-child</code>
    selectors.<br>
</div>

<pre><span id="VALfirst"><span class="keyword">val</span> first</span> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Evaluates to the first node of the given sequence, if the sequence has at
    least one node.<br>
</div>

<pre><span id="VALlast"><span class="keyword">val</span> last</span> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; 'a <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Evaluates the entire given sequence and returns the last node, if one was
    encountered.<br>
</div>

<pre><span id="VALcount"><span class="keyword">val</span> count</span> : <code class="type">'a <a href="#TYPEnodes">nodes</a> -&gt; int</code></pre><div class="info ">
Evaluates to the number of nodes in the given sequence.<br>
</div>

<pre><span id="VALindex_of"><span class="keyword">val</span> index_of</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; int</code></pre><div class="info ">
Evaluates to the index of the given node in its parent's child list. If the
    node has no parent, the index is 1. Note that indices are 1-based, according
    to CSS convention.<br>
</div>

<pre><span id="VALindex_of_element"><span class="keyword">val</span> index_of_element</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; int</code></pre><div class="info ">
Evaluates to the element index of the given element in the parent's child
    list. That is, the index of the given element when the parent's non-element
    children are disregarded. The index is 1-based, in line with CSS
    convention.<br>
</div>

<h2 id="2_Convenience">Convenience</h2>

<pre><span id="VALtags"><span class="keyword">val</span> tags</span> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnodes">nodes</a></code></pre><div class="info ">
Evaluates to all descendant elements of the given node that have the given
    tag name. For example, the following is a sequence of all <code class="code">a</code> elements under
    <code class="code">some_root_node</code>:
<p>

</p><pre class="codepre"><code class="code">some_root_node |&gt; tags "a"
</code></pre>
<p>

    It is equivalent to
</p><p>

</p><pre class="codepre"><code class="code">some_root_node
|&gt; descendants |&gt; elements |&gt; filter (fun e -&gt; name e = "a")
</code></pre>
<p>

    and
</p><p>

</p><pre class="codepre"><code class="code">some_root_node $$ "a"
</code></pre>
<p>

    Note that tag names are case-insensitive.<br>
</p></div>

<pre><span id="VALtag"><span class="keyword">val</span> tag</span> : <code class="type">string -&gt; 'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <code class="code">tags</code>, but evaluates to only the first element, if there is one. So,
    the following selects the first <code class="code">a</code> element under <code class="code">some_root_node</code>:
<p>

</p><pre class="codepre"><code class="code">some_root_node |&gt; tag "a"
</code></pre>
<p>

    If you expect the element to be there, you can do
</p><p>

</p><pre class="codepre"><code class="code">some_root_node |&gt; R.tag "a"
</code></pre>
<p>

    These are equivalent to <code class="code">some_root_node $? "a"</code> and <code class="code">some_root_node $ "a"</code>,
    respectively.<br>
</p></div>

<pre><span id="VALparent"><span class="keyword">val</span> parent</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Given a node, evaluates to its parent element, if it has one. Note that root
    nodes do not have a parent <em>element</em>, as their parent is the <em>document</em>
    node (a.k.a. the soup). <code class="code">parent</code> therefore evaluates to <code class="code">None</code> for root
    nodes. <code class="code">parent n</code> is equivalent to <code class="code">n |&gt; ancestors |&gt; first</code>.<br>
</div>

<pre><span id="VALchild"><span class="keyword">val</span> child</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">child n</code> evaluates to <code class="code">n</code>'s first child, if <code class="code">n</code> has one. Equivalent to
    <code class="code">n |&gt; children |&gt; first</code>.<br>
</div>

<pre><span id="VALchild_element"><span class="keyword">val</span> child_element</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">child_element n</code>, evaluates to <code class="code">n</code>'s first child element, if <code class="code">n</code> has one.
    Equivalent to <code class="code">n |&gt; children |&gt; elements |&gt; first</code>.<br>
</div>

<pre><span id="VALnext_sibling"><span class="keyword">val</span> next_sibling</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">next_sibling n</code> is the next sibling of <code class="code">n</code> in <code class="code">n</code>'s parent's child list, if
    there is such a sibling. It is equivalent to
    <code class="code">n |&gt; next_siblings |&gt; first</code>.<br>
</div>

<pre><span id="VALprevious_sibling"><span class="keyword">val</span> previous_sibling</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <code class="code">next_sibling</code>, but for the preceding sibling instead.<br>
</div>

<pre><span id="VALnext_element"><span class="keyword">val</span> next_element</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
<code class="code">next_element n</code> is the next sibling of <code class="code">n</code> that is an element. It is
    equivalent to <code class="code">n |&gt; next_siblings |&gt; elements |&gt; first</code>.<br>
</div>

<pre><span id="VALprevious_element"><span class="keyword">val</span> previous_element</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> option</code></pre><div class="info ">
Like <code class="code">next_element</code>, but for the preceding siblings instead.<br>
</div>

<pre><span id="VALno_children"><span class="keyword">val</span> no_children</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Evaluates to <code class="code">true</code> if and only if the given node has no child nodes.<br>
</div>

<pre><span id="VALat_most_one_child"><span class="keyword">val</span> at_most_one_child</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Evaluates to <code class="code">true</code> if and only if the given node has at most one child
    node.<br>
</div>

<pre><span id="VALis_root"><span class="keyword">val</span> is_root</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
Evaluates to <code class="code">true</code> if and only if the given node is not a soup (document)
    node, and either has no parent, or its parent is a soup node. In other
    words, determines whether the node is a top-level non-document node.<br>
</div>

<h2 id="2_Printing">Printing</h2>

<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string</code></pre><div class="info ">
Converts the node tree rooted at the given node to an HTML5 string,
    preserving whitespace nodes and not minding human readability
    considerations.<br>
</div>

<pre><span id="VALpretty_print"><span class="keyword">val</span> pretty_print</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; string</code></pre><div class="info ">
Converts the node tree rooted at the given node to a string formatted for
    easy reading. Note that this can change the whitespace structure of the
    HTML, so pretty-printed HTML may display differently in a browser than the
    original parsed document. Pretty-printing is meant for inspection,
    debugging, content diffs, etc., not browser viewing.<br>
</div>

<h2 id="2_Parsingsignals">Parsing signals</h2>
<p>

    Lambda Soup uses <a href=" https://github.com/aantron/markup.ml"> Markup.ml</a>
    internally to parse and write markup. If you wish to:
</p><p>
</p><ul>
<li>avoid intermediate strings when reading or writing,</li>
<li>control how parsing is done, or</li>
<li>run the input or output of Lambda Soup through a filter without having to
      re-parse it,</li>
</ul>

    then you should use the functions below instead of <code class="code">parse</code> and <code class="code">to_string</code>.
<p class="end-of-section-text">

    See the <a href=" http://aantron.github.io/markup.ml/"> Markup.ml documentation</a>
    for the types involved. The
    <a href=" https://github.com/aantron/markup.ml#overview-and-basic-usage"> overview</a>
    may be a good place to start.<br>

</p><pre><span id="VALsignals"><span class="keyword">val</span> signals</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; (Markup.signal, Markup.sync) Markup.stream</code></pre><div class="info ">
Converts the node tree rooted at the given node to a stream of Markup.ml
    signals. This underlies <code class="code">to_string</code> and <code class="code">pretty_print</code>.
<p>

    You can use this function together with <code class="code">Markup.write_xml</code> to output XML
    instead of HTML.<br>
</p></div>

<pre><span id="VALfrom_signals"><span class="keyword">val</span> from_signals</span> : <code class="type">(Markup.signal, Markup.sync) Markup.stream -&gt; <a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Converts a stream of Markup.ml signals to a node tree. This underlies
    <code class="code">parse</code>.
<p>

    You can use this function together with <code class="code">Markup.parse_xml</code> to load XML into
    Lambda Soup.
</p><p>

    At the moment, namespaces are ignored.<br>
</p></div>

<h2 id="2_Equality">Equality</h2>

<pre><span id="VALequal"><span class="keyword">val</span> equal</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
<code class="code">equal n n'</code> recursively tests the node trees rooted at <code class="code">n</code> and <code class="code">n'</code> for
    equality. To test <code class="code">true</code>, the trees must be identical, including whitespace
    text nodes. Class attributes and other multi-valued attributes are compared
    literally: classes must be listed in the same order, with the same amount of
    whitespace in the attribute value. During comparison, adjacent text nodes
    are merged, and empty text nodes are ignored. This is the standard
    normalization procedure.<br>
</div>

<pre><span id="VALequal_modulo_whitespace"><span class="keyword">val</span> equal_modulo_whitespace</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; bool</code></pre><div class="info ">
<code class="code">equal_modulo_whitespace n n'</code> is like <code class="code">equal n n'</code>, but all text nodes have
    their values passed through <code class="code">String.trim</code>. Nodes that become empty are then
    ignored for the purpose of comparison, as in <code class="code">equal</code>. This is analogous to
    the operation of <code class="code">trimmed_texts</code>.<br>
</div>

<h2 id="2_Mutation">Mutation</h2>

<pre><span id="VALcreate_element"><span class="keyword">val</span> create_element</span> : <code class="type">?id:string -&gt;<br>       ?class_:string -&gt;<br>       ?classes:string list -&gt;<br>       ?attributes:(string * string) list -&gt;<br>       ?inner_text:string -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a></code></pre><div class="multiline-member info">
<code class="code">create_element tag</code> creates a new element with the name <code class="code">tag</code>.
<p>

    If <code class="code">~attributes</code> is specified, the given attributes are added to the
    element. <code class="code">~attributes</code> defaults to <code class="code">[]</code>.
</p><p>

    If <code class="code">~classes</code> is specified, the class names are concatenated into a single
    string <code class="code">s</code> and the <code class="code">class</code> attribute is set on the element to the resulting
    value. This takes precedence over <code class="code">~attributes</code>.
</p><p>

    If <code class="code">~class</code> is specified, the class is set on the element. This takes
    precedence over both <code class="code">~attributes</code> and <code class="code">~classes</code>.
</p><p>

    If <code class="code">~id</code> is specified, the id is set. This takes precedence over
    <code class="code">~attributes</code>.
</p><p>

    If <code class="code">~inner_text</code> is specified, a text node is created with the given string,
    and made the single child of the new element.<br>
</p></div>

<pre><span id="VALcreate_text"><span class="keyword">val</span> create_text</span> : <code class="type">string -&gt; <a href="#TYPEgeneral">general</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Creates a new text node with the given content.<br>
</div>

<pre><span id="VALcreate_soup"><span class="keyword">val</span> create_soup</span> : <code class="type">unit -&gt; <a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a></code></pre><div class="info ">
Creates a new document node.<br>
</div>

<pre><span id="VALappend_child"><span class="keyword">val</span> append_child</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">append_child element n</code> adds <code class="code">n</code> to the end of the child list of
    <code class="code">element</code>.<br>
</div>

<pre><span id="VALprepend_child"><span class="keyword">val</span> prepend_child</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">prepend_child element n</code> adds <code class="code">n</code> to the beginning of the child list of
    <code class="code">element</code>.<br>
</div>

<pre><span id="VALinsert_at_index"><span class="keyword">val</span> insert_at_index</span> : <code class="type">int -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">insert_at_index k element n</code> makes <code class="code">n</code> the <code class="code">k</code>th child of <code class="code">element</code>. Note
    that the index is 1-based. Pre-existing children with indices formerly <code class="code">k</code>
    or higher are moved after <code class="code">n</code>. If <code class="code">k</code> is outside the range of valid indices,
    <code class="code">n</code> is inserted at the beginning or end of the list, respectively if <code class="code">k</code> is
    less than one or greater than the number of pre-existing children plus
    one.<br>
</div>

<pre><span id="VALinsert_before"><span class="keyword">val</span> insert_before</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">insert_before n n'</code> inserts <code class="code">n'</code> immediately before <code class="code">n</code> in <code class="code">n</code>'s parent's
    child list.<br>
</div>

<pre><span id="VALinsert_after"><span class="keyword">val</span> insert_after</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">insert_after n n'</code> inserts <code class="code">n'</code> immediately after <code class="code">n</code> in <code class="code">n</code>'s parent's
    child list.<br>
</div>

<pre><span id="VALdelete"><span class="keyword">val</span> delete</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Deletes the given node by unlinking it from its parent. If the node has
    children, they are implicitly deleted by this operation as well, in the
    sense that they become unreachable from the document.<br>
</div>

<pre><span id="VALclear"><span class="keyword">val</span> clear</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Deletes all children of the given node.<br>
</div>

<pre><span id="VALreplace"><span class="keyword">val</span> replace</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; 'b <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">replace n n'</code> replaces <code class="code">n</code> with <code class="code">n'</code> by modifying <code class="code">n</code>'s parent's child
    list. All children of <code class="code">n</code> are implicitly deleted by this operation because
    they are unlinked.<br>
</div>

<pre><span id="VALswap"><span class="keyword">val</span> swap</span> : <code class="type"><a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">swap element element'</code> replaces <code class="code">element</code> with <code class="code">element'</code>. All children of
    <code class="code">element</code> are transferred to <code class="code">element'</code>, and all original children of
    <code class="code">element'</code> are transferred to <code class="code">element</code>.<br>
</div>

<pre><span id="VALwrap"><span class="keyword">val</span> wrap</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">wrap n element</code> inserts <code class="code">element</code> in the place of <code class="code">n</code>, and then makes <code class="code">n</code>
    <code class="code">element</code>'s child. All original children of <code class="code">element</code> are unlinked.<br>
</div>

<pre><span id="VALunwrap"><span class="keyword">val</span> unwrap</span> : <code class="type">'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">unwrap n</code> unlinks <code class="code">n</code>, and inserts all of <code class="code">n</code>'s children as children of
    <code class="code">n</code>'s parent.<br>
</div>

<pre><span id="VALappend_root"><span class="keyword">val</span> append_root</span> : <code class="type"><a href="#TYPEsoup">soup</a> <a href="#TYPEnode">node</a> -&gt; 'a <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">append_root soup n</code> adds <code class="code">n</code> as the last root node of <code class="code">soup</code>.<br>
</div>

<pre><span id="VALset_name"><span class="keyword">val</span> set_name</span> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Sets the tag name of the given element to the given value.<br>
</div>

<pre><span id="VALset_attribute"><span class="keyword">val</span> set_attribute</span> : <code class="type">string -&gt; string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">set_attribute attr v element</code> sets the value of attribute <code class="code">attr</code> on
    <code class="code">element</code> to <code class="code">v</code>. If the attribute is not present, it is added to <code class="code">element</code>.
    If it is already present, the value is replaced.<br>
</div>

<pre><span id="VALdelete_attribute"><span class="keyword">val</span> delete_attribute</span> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
Removes the given attribute from the given element. If the attribute is not
    present, has no effect.<br>
</div>

<pre><span id="VALadd_class"><span class="keyword">val</span> add_class</span> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">add_class c element</code> adds class <code class="code">c</code> to <code class="code">element</code>, if <code class="code">element</code> does not
    already have class <code class="code">c</code>.<br>
</div>

<pre><span id="VALremove_class"><span class="keyword">val</span> remove_class</span> : <code class="type">string -&gt; <a href="#TYPEelement">element</a> <a href="#TYPEnode">node</a> -&gt; unit</code></pre><div class="info ">
<code class="code">remove_class c element</code> removes class <code class="code">c</code> from <code class="code">element</code>, if <code class="code">element</code> has
    class <code class="code">c</code>.<br>
</div>

<h2 id="2_Optionconveniencemodule">Option convenience module</h2>

<pre><span class="keyword">module</span> R: <code class="code">sig</code> .. <code class="code">end</code></pre><div class="info">
For each function <code class="code">f</code> in Lambda Soup whose result type is an option,
    provides a function <code class="code">R.f</code> such that <code class="code">R.f ...</code> = <code class="code">f ... |&gt; require</code>, that is,
    a version of <code class="code">f</code> that can raise <code class="code">Failure</code> instead of returning an option.
</div>

<h2 id="2_IO">I/O</h2>
<p>

    Lambda Soup is not an I/O library. However, it provides a few simple helpers
    based on standard I/O functions in
    <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#6_Inputoutput">
    <code class="code">Pervasives</code></a>. These should not be used for "serious" code. They are only
    for when you need to get something done quickly, and/or don't care about
    corner cases or excellent reliability. In such cases, they allow you to
    avoid writing I/O wrappers or using additional libraries.
</p><p>

    Using these, you can write little command-line scrapers and filters:
</p><p>

</p><pre class="codepre"><code class="code">let () =
  let soup = read_channel stdin |&gt; parse in
  let () = (* ...do things to soup... *) in

  soup $ "div.view-count" |&gt; R.leaf_text |&gt; print_endline
  (* ...or... *)
  soup |&gt; to_string |&gt; write_channel stdout
</code></pre>
<p>

    If the above is compiled to a file <code class="code">scrape</code>, you can then run
</p><p>

</p><pre class="codepre"><code class="code">curl -L "http://location.com" | ./scrape
</code></pre>
<p class="end-of-section-text">

    to get the view count or transformed HTML, respectively.<br>

</p><pre><span id="VALread_file"><span class="keyword">val</span> read_file</span> : <code class="type">string -&gt; string</code></pre><div class="info ">
Reads the entire contents of the file with the given path. Raises
    <code class="code">Sys_error</code> on failure.<br>
</div>

<pre><span id="VALread_channel"><span class="keyword">val</span> read_channel</span> : <code class="type">Pervasives.in_channel -&gt; string</code></pre><div class="info ">
Reads all bytes from the given channel.<br>
</div>

<pre><span id="VALwrite_file"><span class="keyword">val</span> write_file</span> : <code class="type">string -&gt; string -&gt; unit</code></pre><div class="info ">
<code class="code">write_file path data</code> writes <code class="code">data</code> to the file given by <code class="code">path</code>. If the
    file already exists, it is truncated (erased). If you want to append to
    file, use
    <a href=" http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALopen_out_gen">
    <code class="code">open_out_gen</code></a> with the necessary flags, and pass the resulting channel to
    <code class="code">write_channel</code>. Raises <code class="code">Sys_error</code> on failure.<br>
</div>

<pre><span id="VALwrite_channel"><span class="keyword">val</span> write_channel</span> : <code class="type">Pervasives.out_channel -&gt; string -&gt; unit</code></pre><div class="info ">
Writes the given data to the given channel.<br>
</div>
<div class="footer">
  Copyright  2016 Anton Bachin. Released under the BSD 2-clause license.
  See
  <a href="https://github.com/aantron/lambda-soup/blob/master/docs/LICENSE">
    LICENSE
  </a>
  <br>
  This page is part of the documentation for
  <a href="https://github.com/aantron/lambda-soup">Lambda Soup</a>.
</div></body></html>